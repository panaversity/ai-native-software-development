# Part 1 Specification: Introducing AI-Driven Development

**Feature**: Book Structure - Part 1 Detailed Specification
**Created**: 2025-10-29
**Status**: Ready for chapter-planner subagent
**Input**: 002-book-structure spec.md + user narrative
**Output**: For chapter-planner: `specs/part-1/chapter-01-plan.md` through `specs/part-1/chapter-05-plan.md`

---

## Part 1 Overview

### Title
**"Introducing AI-Driven Development: The Billion-Dollar Opportunity From Coder to Super Orchestrator"**

### Purpose

Part 1 establishes the foundational mindset shift that transforms how developers think about their role in the AI era. Readers transition from viewing themselves as "coders who write code" to "orchestrators who design systems and direct intelligent agents."

### Target Audience

- Absolute beginners (no prior AI, no prior Claude Code/Gemini CLI, no prior Spec-Kit Plus)
- Working professionals pivoting to AI-driven development
- Solo entrepreneurs interested in building vertical agentic solutions
- Technical managers understanding the paradigm shift

### Part 1 Philosophy

- **Cognitive Load**: LIGHT (foundational concepts, lots of scaffolding)
- **Scaffolding**: HEAVY (show-then-explain, guided examples, zero gatekeeping language)
- **Review Cycles**: 2-3 (expect feedback and iteration)
- **Concept Density**: 3-4 key concepts per chapter (time to absorb)

### Part 1 Learning Outcomes

By the end of Part 1, readers will be able to:

1. **Mindset**: Understand and articulate why "orchestration" replaces "coding" in the AI era
2. **Opportunity**: Recognize the billion-dollar opportunity in building vertical agentic solutions
3. **Foundation**: Know the 9 technological revolutions that made this moment possible
4. **Tools**: Have Claude Code, Gemini CLI, and Spec-Kit Plus installed and verified
5. **Hands-On**: Have executed a complete spec-driven development cycle (spec → implementation → test → deploy)
6. **Confidence**: Be comfortable iterating with AI agents as partners, not replacements

---

## Chapter Breakdown

### Chapter 1: Welcome to Agent-Native Education
**Subtitle**: "The Paradigm Shift from Code Writer to Agent Orchestrator"

#### Purpose
Introduce readers to the **agent-native model of computer science education** where AI is a **co-learner**, **collaborator**, and **creative partner**. Establish the foundational mindset shift from viewing oneself as a "code writer" to an "agent orchestrator." Ground the vision in the economic and technological reality of the AI coding revolution.

#### Learning Outcomes
By the end of this chapter, readers will:
- Understand that AI augments rather than replaces human capability and judgment
- Grasp the concept of "agent orchestrator" (specification writer, system architect, agent director, quality arbiter)
- See why solo developers can now build significant solutions with AI assistance
- Understand the $3 trillion software development market and why this moment is unprecedented
- Know the major technological and economic forces enabling AI-driven development
- Recognize vertical markets (finance, healthcare, education, legal, real estate) as the real opportunity
- Feel motivated and included, not threatened, by the AI-driven paradigm shift
- Understand what "agent-native education" means and what to expect in this book

#### Content Source & Grounding
- **Primary**: AI Coding Revolution Paper (https://github.com/panaversity/spec-kit-plus/blob/main/docs-plus/ai_coding_revolution_paper.md)
- **Secondary**: Project Constitution (Principles 1, 8, 9)
- **Pedagogical Model**: Agent-native education (AI as co-learner, collaborator, creative partner)

#### Key Topics to Cover
1. **The Paradigm Shift**: From "code writer" to "agent orchestrator"
   - The fear narrative: "Will AI replace me?" (acknowledge directly)
   - The reality: AI amplifies human judgment, taste, and design choices
   - Real examples: Solo builders creating valuable solutions with AI
   - The new role: Four dimensions of an agent orchestrator

2. **The Economic & Technological Foundation**: Why THIS moment matters
   - The $3 trillion software development industry and 30 million developers
   - AI coding revolution as the first truly large market for AI
   - Autonomous agents vs. copilots (autonomy vs. assistance)
   - Key enablers: context engineering, sandbox execution, version control for machine-generated code
   - Infrastructure evolution: cloud-native systems enabling large-scale AI

3. **The Competitive Landscape**: Where the REAL opportunity is
   - The "snakes and ladders" pattern (Layer 1: consumer AI, Layer 2: horizontal agents, Layer 3: vertical specialists)
   - Why limited winners at Layers 1-2, unlimited winners at Layer 3
   - Vertical examples: Finance, healthcare, education, legal, real estate
   - How deep domain integration + fine-tuned models + existing software connections = defensible advantage

4. **Agent-Native Education**: The Model Behind This Book
   - What "agent-native" means: AI participates actively (co-learner, collaborator, creative partner)
   - Learning WITH AI vs. Learning FROM AI (critical distinction)
   - How this book embodies the model throughout
   - What to expect: specifications, directing AI partners, understanding reasoning

5. **Your Role as Agent Orchestrator**: Four Dimensions
   - Specification writer: Clear requirements precede implementation
   - System architect: Design intelligent system topology
   - Agent director: Guide AI partners toward good solutions
   - Quality arbiter: Evaluate and refine AI-generated work

6. **Preview of the Journey**: Parts 2-7 Overview
   - Part 1: Mindset shift and agent-native education foundations
   - Part 2: Tools (Claude Code, Gemini CLI, Spec-Kit Plus)
   - Part 3-7: Python, agentic systems, MCP integration, production deployment

#### Prerequisites
None. This is the entry point to the book.

#### Success Criteria
- 90%+ of readers articulate (in their own words) that AI amplifies rather than replaces human capability
- 85%+ of readers can name and explain at least 3 major technological/economic shifts from the AI coding revolution
- 80%+ of readers identify at least one vertical market where they could build specialized solutions
- 85%+ of readers understand what "agent-native education" means and what to expect in the book
- 90%+ of readers feel motivated (not threatened) by the AI-driven paradigm shift
- 80%+ of readers can explain what an "agent orchestrator" does and why it's a valuable role
- Readers complete chapter without significant confusion (measured by comprehension check)
- 75%+ of readers report readiness to engage with AI as a co-learner in subsequent chapters

#### Pedagogical Approach
- **Show → Explain → Practice → Assess**: Start with examples, connect to patterns, practice with reflection exercise, assess with comprehension check
- **Heavy Scaffolding**: Define every term on first use, use analogies, avoid gatekeeping language
- **Multiple Entry Points**: Narrative flow, bullet points, visuals (diagrams), examples (solo builders, verticals)
- **Emotional Intelligence**: Acknowledge fears directly, validate existing skills, use inclusive language, celebrate opportunity
- **Constitutional Alignment**: Principle 1 (AI-First), Principle 8 (Inclusivity), Principle 9 (Show-then-Explain)

#### Approximate Content
- 3,500-4,500 words total
- 6 major sections with defined word counts (600-1,200 per section)
- 3 diagrams: (1) Snakes & Ladders pattern, (2) Agent Orchestrator roles, (3) Agent-Native Education model
- 3-4 real examples: 2 solo builder examples, 3+ vertical specialization examples
- 4 analogies: orchestrator vs. musician, architect vs. construction worker, coach vs. player, conductor vs. performer
- 1 comprehension check (formative, not graded)
- 1 reflection exercise (personal, non-graded)

---

### Chapter 2: Understanding AI Tools
**Subtitle**: "The Nine Revolutions That Made This Possible"

#### Purpose
Explain the technological foundation. Answer: "What changed in the technology that made orchestration possible?"

#### Learning Outcomes
By the end of this chapter, readers will:
- Understand the 9 technological revolutions that created this moment
- Grasp why AI coding agents are a distinct market tier (not just "Copilot v2")
- Recognize the pattern: each revolution alone is transformative; together they're unprecedented
- See why hyperscalers (OpenAI, Google, Anthropic, Microsoft) are consolidating
- Understand why the real opportunity is in vertical markets (your niche)

#### Key Topics to Cover (The 9 Revolutions)
1. **Frontier LLMs Crossed Critical Thresholds** (2023-2025)
   - Reasoning: Complex multi-step problem solving
   - Code generation: Production-quality implementation
   - Tool use: Reliable API calling and integration
   - Low latency: Sub-second response times
   - Long context: 200K+ token windows for entire codebases

2. **Mainstream Adoption Among Developers** (2024-2025)
   - GitHub Copilot: 50M+ developers
   - Cursor IDE: Fastest-growing IDE in history
   - Industry surveys: 80%+ of pro developers use AI daily
   - Enterprise adoption: Fortune 500 companies standardizing

3. **AI Coding Agents Emerged** (Late 2024-2025)
   - Claude Code: $500M ARR in 2 months
   - Gemini CLI: 1M+ developers
   - Cursor Composer: Agentic development in IDE
   - Distinction: Not Copilot (assistant) but agents (autonomous executors)

4. **Natural Language Specifications Became Executable** (2024-2025)
   - Specs written in plain English/Markdown
   - AI interprets and executes directly
   - No translation loss from requirements to code
   - Rapid iteration: Spec → Implementation in minutes

5. **Model Context Protocol (MCP) Standardized Tool Integration** (2024)
   - Anthropic-led standard: Adopted by OpenAI, Google, Microsoft
   - 200+ pre-built integrations: Databases, APIs, cloud services
   - Community-driven: Exponential growth of connectors
   - Cross-platform: Works with all major AI systems

6. **AI-Native IDEs Matured** (2023-2025)
   - Cursor: Purpose-built for AI pair programming
   - VS Code: AI extensions ecosystem
   - Claude Code: Native CLI integration
   - Real-time collaboration: Human + AI co-creation

7. **Cloud-Native Infrastructure Became Production-Ready** (2020-2025)
   - Docker: Standard containerization
   - Kubernetes: Enterprise orchestration
   - Dapr: Simplified microservices
   - Ray: Distributed AI/ML workloads
   - Kafka: Event streaming at scale

8. **Composable Architectures Enabled Modular AI Systems** (2024-2025)
   - OpenAI Agents SDK: Framework for composable agents
   - Multi-agent orchestration: Proven at scale
   - Swarm patterns: Self-organizing agent systems
   - Reusable components: Skills, prompts, integrations

9. **Universal Deployment Platforms Simplified Distribution** (2023-2025)
   - Vercel/Netlify: Frontend hosting
   - Railway/Fly.io: Full-stack deployment
   - AWS Amplify: Serverless backends
   - Kubernetes: Standardized orchestration

#### The Perfect Storm
Explain how each revolution alone would be transformative. Together, they create unprecedented conditions where solo developers can build billion-dollar vertical solutions.

#### The Pattern: Snakes and Ladders
- **Layer 1**: Consumer AI → Two winners (OpenAI 800M users, Google Gemini)
- **Layer 2**: Horizontal Coding Agents → Two winners per domain (Claude Code #1, Gemini CLI #2)
- **Layer 3**: Vertical Agents → **Your opportunity**: Unlimited winners across every industry vertical

Each industry vertical (finance, education, healthcare, legal, real estate) will play out the same competitive dynamics. Winners will be those who:
1. Build fine-tuned models tailored to domain-specific needs
2. Create deep integrations with existing industry software
3. Deliver complete agentic solutions that provide tangible workflow improvements

#### Prerequisites
- Chapter 1 understanding (mindset shift to orchestration)
- No deep technical knowledge required

#### Success Criteria
- Readers can name 3+ of the 9 revolutions and explain them in their own words
- Readers understand why coding agents are distinct from Copilot
- Readers grasp the Snakes and Ladders pattern and why Layer 3 (verticals) is where the opportunity is
- Readers see themselves in the opportunity (not as threat, but as possibility)

#### Pedagogical Approach
- **Timeline visualization**: Show when each revolution happened (2020-2025)
- **Impact visualizations**: Illustrate each revolution's market/technical impact
- **Real data**: ARR numbers, developer adoption curves, market size estimates
- **Pattern recognition**: Help readers see the Snakes and Ladders pattern in their own industry
- **Just enough technical detail**: Explain what each revolution enables without overwhelming

#### Approximate Content
- 4,000-5,000 words
- 9 subsections (one per revolution), 400-600 words each
- 2-3 timeline diagrams or impact illustrations
- 1 Snakes and Ladders visualization showing the competitive layers
- 2-3 industry vertical examples (finance, education, healthcare) showing the pattern
- 1 end-of-chapter exercise: "What vertical could YOU dominate?"

---

### Chapter 3: Setting Up Your Environment
**Subtitle**: "Tools for Specification-Driven Development"

#### Purpose
Get hands-on. Answer: "How do I install and verify the tools I'll use?"

#### Learning Outcomes
By the end of this chapter, readers will:
- Have Claude Code installed and verified on their machine
- Have Gemini CLI installed and verified
- Have Spec-Kit Plus installed and configured
- Understand the role each tool plays in spec-driven development
- Be able to troubleshoot common installation issues
- Have their first "end-to-end" verification: Write a spec → CLI processes it

#### Key Topics to Cover
1. **Claude Code Installation**
   - Prerequisites (Python 3.13+, terminal skills)
   - Install via package manager or source
   - Verify installation: `claude-code --version`
   - Quick test: `claude-code --help`

2. **Gemini CLI Installation**
   - Prerequisites (same as Claude Code)
   - Install via package manager
   - Set up authentication (Google API key)
   - Verify installation: `gemini --version`
   - Quick test: `gemini --help`

3. **Comparison: Claude Code vs. Gemini CLI**
   - Architecture differences (Haiku vs. Gemini)
   - Pricing differences
   - Capability differences (which is better for what)
   - When to use each one (workflow decision-making)

4. **Spec-Kit Plus Setup**
   - What Spec-Kit Plus is (project scaffold, templates, subagent framework)
   - Installation: Clone repo, install dependencies
   - Directory structure walkthrough
   - Configuration for your environment

5. **End-to-End Verification**
   - Write a simple spec (markdown file describing a task)
   - Run Claude Code on the spec
   - Review the generated output
   - Understand what Claude Code did
   - Know what to expect in Chapter 4

6. **Troubleshooting**
   - Common installation errors and fixes
   - Authentication issues
   - Path/environment variable problems
   - Where to find help

#### Prerequisites
- Chapters 1-2 understanding (context for why these tools matter)
- Terminal/command-line familiarity (assumed)
- GitHub account (for Spec-Kit Plus)

#### Success Criteria
- `claude-code --version` returns a version number
- `gemini --version` returns a version number
- Spec-Kit Plus directory structure is visible on disk
- User has written and successfully processed their first spec file
- User understands when to use Claude Code vs. Gemini CLI

#### Pedagogical Approach
- **Screenshot walkthrough**: Show each installation step visually
- **Copy-paste ready**: Provide exact commands (bash, PowerShell for Windows)
- **Explanation**: After each step, explain what it did and why
- **Troubleshooting**: Include common errors and solutions BEFORE users encounter them
- **Hands-on validation**: End-of-chapter exercise verifies everything works

#### Approximate Content
- 2,500-3,500 words
- 15-20 screenshots (one per major step)
- 3 comparison tables (Claude Code vs. Gemini vs. Copilot)
- 1 directory structure diagram (Spec-Kit Plus layout)
- 1 troubleshooting decision tree (if X, then do Y)
- 1 hands-on exercise: Install all three tools

---

### Chapter 4: Your First Program with AI
**Subtitle**: "Write Spec → Generate → Test → Deploy"

#### Purpose
Execute the first complete spec-driven development cycle hands-on. Answer: "How do I actually build something using specs and AI?"

#### Learning Outcomes
By the end of this chapter, readers will:
- Have written a clear specification for a real task
- Have used Claude Code to generate implementation from that spec
- Have seen AI-generated code and understood it (not magic, logic)
- Have tested the generated code and confirmed it works
- Have deployed the result (even if locally)
- Understand why spec-driven workflows are faster and more reliable than traditional coding
- Have confidence to do this process again with their own ideas

#### Key Topics to Cover
1. **Writing Effective Specifications**
   - What makes a good spec (clear requirements, edge cases, success criteria)
   - What NOT to do (vague requirements, missing acceptance criteria)
   - Specification template (use Spec-Kit Plus template)
   - Example spec: "Build a function that validates email addresses"

2. **Submitting to Claude Code**
   - How to pass a spec to Claude Code (CLI command, file input)
   - Understanding what you're asking Claude Code to do
   - What Claude Code will ask for clarification on (and how to respond)

3. **Reading AI-Generated Code**
   - Don't panic: It's real code, not magic
   - How to read unfamiliar code (start at the entry point)
   - Type hints: Your ally in understanding generated code
   - Docstrings: What Claude Code generates automatically

4. **Testing the Generated Code**
   - Running the code: `python -m pytest`
   - Understanding test output (passing vs. failing)
   - What to do if tests fail
   - Adding your own tests (Claude Code can help)

5. **Deploying the Result**
   - Local deployment: Run as Python script
   - Package as CLI tool: Use PyPI or equivalent
   - Deploy to cloud: Brief intro (detailed in Part 4)
   - Verification: Is it actually running? How to tell?

6. **Understanding the Workflow**
   - Why this is faster than manual coding: No typos, no syntax errors (AI handles it)
   - Why this is more reliable: Specs force clarity; AI is literally executable
   - Why iteration is different: You refine the spec, not the code
   - The feedback loop: Spec → Code → Test → Feedback → Refined Spec

#### Hands-On Exercise
Build a real (but small) application:
- **Task**: Email validation function that handles 10 specific edge cases
- **Your role**: Write the spec with 10 acceptance scenarios
- **Claude Code's role**: Implement, test, document
- **Your role again**: Verify it works and understand the code
- **Result**: Deployed email validator (even if locally)

#### Prerequisites
- Chapters 1-3 understanding and completion
- Tools installed (Claude Code, Gemini CLI, Spec-Kit Plus)
- Comfortable reading Python code (don't need to write it yet)

#### Success Criteria
- Spec is clear enough that Claude Code understands it
- Claude Code generated working code
- All tests pass
- User can read and explain the generated code
- Code is deployed (locally is fine)
- User can articulate why the spec-driven workflow is powerful

#### Pedagogical Approach
- **Narrative walkthrough**: Tell a story (email validation) from spec to deploy
- **Show the exact commands**: Copy-paste ready, works first time
- **Screen recordings**: Show the workflow in action (text + visuals)
- **Code annotations**: Explain what each generated function does
- **Troubleshooting**: Include common issues and solutions
- **Reflection**: End with "Why did this work?" to reinforce understanding

#### Approximate Content
- 4,000-5,000 words
- 1 full spec example (annotated with why each section matters)
- 10-12 screenshots (showing CLI commands, output, generated code)
- 2 code listings (generated code, test code) with inline annotations
- 1 workflow diagram (spec → generate → test → deploy)
- 1 hands-on exercise (build email validator from scratch)

---

### Chapter 5: Debugging and Iterating with AI
**Subtitle**: "When Things Go Wrong (And They Will)"

#### Purpose
Build resilience and confidence. Answer: "How do I work effectively when AI makes mistakes or I misunderstood what I needed?"

#### Learning Outcomes
By the end of this chapter, readers will:
- Understand common failure modes when working with AI agents (and how to fix them)
- Know how to read error messages and understand what they mean
- Have practiced the iteration loop: Agent → Your Feedback → Better Output
- Be confident debugging AI-generated code
- Know when to ask for human help vs. pushing the agent further
- Have built resilience: Failures are normal and fixable, not signals to give up

#### Key Topics to Cover
1. **Common Failure Modes**
   - Misunderstood spec (AI generated code that technically met your spec but wasn't what you meant)
   - Hallucinated APIs (AI referenced libraries that don't exist)
   - Edge case failures (code works for happy path, fails for edge cases)
   - Performance issues (code works but is slow)
   - Security issues (code works but isn't secure)

2. **Reading and Understanding Error Messages**
   - Stack traces: What they mean and how to read them
   - Common Python errors: ValueError, TypeError, ImportError, etc.
   - AI's error interpretations: How Claude Code reads and explains errors
   - Turning errors into specifications: "AI, the code fails with ImportError. Here's why..."

3. **The Iteration Loop**
   - Step 1: AI generates code
   - Step 2: You test it
   - Step 3: You report the failure (clearly, with error message)
   - Step 4: AI understands the problem
   - Step 5: AI refines the code
   - Step 6: You test again
   - Repeat until success

4. **Debugging AI-Generated Code**
   - Adding print statements (yes, it's still valid)
   - Using debuggers (Claude Code can help)
   - Isolating the problem (which line is failing?)
   - Asking Claude Code to explain (it will)

5. **Refining Your Specs Based on Failures**
   - You learned what you actually needed
   - Update the spec with that learning
   - Give the updated spec to Claude Code
   - This prevents repeated failures

6. **When to Ask for Human Help**
   - You've iterated 3+ times and still failing: Time to ask for help
   - The error message doesn't make sense: Paste it and ask a human
   - You think there's a fundamental problem: Get another perspective
   - Knowing when to escalate is a skill (not a failure)

#### Hands-On Exercise
Intentionally break the code from Chapter 4 and fix it:
- **Task**: Email validator has 3 deliberate bugs
- **Your role**: Find each bug, understand it, report it clearly to Claude Code
- **Claude Code's role**: Fix each one
- **Your role again**: Verify the fix works
- **Reflection**: What did you learn about specs, code, debugging?

#### Prerequisites
- Chapters 1-4 understanding and completion
- Comfort reading error messages (even if you don't understand them yet)
- Completed the Chapter 4 email validator exercise

#### Success Criteria
- User has iterated successfully (spec → code → test → failure → feedback → refined code)
- User can read and explain a Python error message
- User can add print statements to debug
- User can refine their spec based on learned requirements
- User has confidence that failures are solvable

#### Pedagogical Approach
- **Safety first**: Normalize failures. "This is expected. Here's how to handle it."
- **Show real failures**: Not sanitized examples, but actual messy debugging
- **Step-by-step walkthrough**: How to systematically narrow down a problem
- **Emotional intelligence**: Acknowledge that debugging is frustrating and give coping strategies
- **Celebration**: Emphasize that fixing a problem is a success, not a failure to avoid

#### Approximate Content
- 3,500-4,500 words
- 5-7 example failure scenarios (common mistakes)
- 3 error message walkthroughs (how to read them)
- 1 iteration loop diagram (spec → code → test → feedback → ...)
- 10-12 screenshots (showing debugging in action)
- 1 decision tree: "When to ask for human help"
- 1 hands-on exercise (debug the email validator)

---

## Part 1 Connection to Rest of Book

### Chapter 1 Prepares You For:
- **Part 2**: You now understand why tools matter and what you'll use them for
- **Part 3**: You now understand why clear communication (specs) is essential
- **Part 4**: You now understand why Python and type hints are the language of orchestration

### Chapter 2 Prepares You For:
- **Part 5**: You now understand the Spec-Kit Plus methodology that Part 5 teaches in detail
- **Part 6**: You now understand why building agents is the logical next step
- **Part 7**: You now understand why MCP integration creates defensible advantages

### Chapter 3 Prepares You For:
- **Chapter 4**: You have the tools. Now use them.
- **Part 2-7**: Every part will assume you have these tools working

### Chapter 4 Prepares You For:
- **Chapter 5**: You've done it once successfully. Now handle failures gracefully.
- **Part 2**: You now understand Claude Code's workflow; Part 2 teaches you to choose the right tool
- **Part 3**: You now understand specs; Part 3 teaches you to write better specs
- **Part 4**: You now understand code execution; Part 4 teaches you to write Python like a pro

### Chapter 5 Prepares You For:
- **All of Part 2-7**: You now know how to iterate, debug, and refine. These skills apply everywhere.
- **Real-world projects**: You have resilience and mental models for handling unexpected problems

---

## Part 1 Success Metrics

| Metric | Success Measure | Target |
|--------|-----------------|--------|
| **Mindset Shift** | Readers articulate "orchestration" vs. "coding" clearly | 90%+ of readers can explain in own words |
| **Opportunity Recognition** | Readers identify a vertical market they could serve | 80%+ identify at least one |
| **9 Revolutions** | Readers can name and explain 3+ revolutions | 85%+ can explain 3+ |
| **Tools Installed** | All 3 tools working without errors | 95%+ successful installation |
| **Hands-On Completion** | Readers complete both exercises (Chapters 4-5) | 80%+ complete both |
| **Confidence** | Readers feel ready for Part 2 | 85%+ agree |
| **Code Understanding** | Readers can read and explain generated code | 80%+ demonstrate ability |
| **Iteration Comfort** | Readers have iterated successfully on a spec | 80%+ have done 2+ iterations |

---

## Part 1 Quality Standards

All Part 1 content MUST:
- ✅ Use the 8 domain skills (learning-objectives, concept-scaffolding, code-example-generator, exercise-designer, assessment-builder, technical-clarity, book-scaffolding, ai-augmented-teaching)
- ✅ Include type hints on all Python code
- ✅ Show pedagogical principle: Show → Explain → Practice → Assess
- ✅ Zero gatekeeping language ("simple", "obvious", "just")
- ✅ Align with Constitution principles (esp. Principle 1: AI-First, Principle 8: Inclusivity, Principle 9: Show-then-Explain)
- ✅ Include testing for all code examples
- ✅ Provide multiple reading paths (narrative, skimmers can follow bullet points)
- ✅ Include accessibility considerations (alt text, high contrast, clear language)

---

## Part 1 Review Cycles

Expect 2-3 review cycles:

1. **First Draft**: Content complete, structure sound
2. **First Review**: Check for clarity, correctness, alignment with Constitution
3. **Second Review** (if needed): Refine based on feedback, update examples
4. **Final**: Ready for readers

---

## Next Steps After Part 1

Once Part 1 is approved and ready for writing:

1. **Invoke chapter-planner subagent** with this spec as input
2. **Output**: `specs/part-1/chapter-01-plan.md` through `specs/part-1/chapter-05-plan.md`
3. **Then invoke lesson-writer subagent** to write each chapter's lessons iteratively
4. **Finally invoke technical-reviewer** to validate completed Part 1
5. **Once Part 1 is in implementation**: Create Part 2 spec (same process)

---
